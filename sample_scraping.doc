import requests
import pprint
from bs4 import BeautifulSoup
import json
import unicodecsv as csv
import sys
import os
import psycopg2
import psycopg2.extras
sys.path.append(os.getcwd())
from settings.generic import Insertion

class WebDelLocations(Insertion):
	"""docstring"""
	def __init__(self, city):
		super(WebDelLocations, self).__init__()
		self.city_name = city
		self.base_url = 'yourbaseurl'

	def get_lat_lng(self, search_string):

		apikey = self.google_api_keys[5]
		print search_string
		r = requests.get('https://maps.googleapis.com/maps/api/place/autocomplete/json?input='+
							search_string
							+'&types=geocode&language=en&key=' + apikey,
							verify = False)
		source = r.json()

		try:
			# getting the first prediction
			key = source['predictions'][0]['place_id']
			desc = source['predictions'][0]['description']
			k = requests.get('https://maps.googleapis.com/maps/api/place/details/json?placeid='+key
			+'&key='+ apikey,verify = False)
			loc = k.json()
			# print loc
			try:
				l = loc['result']['geometry']['location']
				lat = l['lat']
				lng = l['lng']
				name = loc['result']['formatted_address']
				print lat,lng
			except Exception as e:
				print str(e)
				return 0, 0, ''
		except Exception as e:
			print str(e)
			return 0, 0, ''
		return lat, lng, key

	def location_fetcher(self, *args):

		writer = args[3]
		hit = ("some_url/get_store/lat/"+str(args[0])+"/lng/"+
								str(args[1])+"/locality_name/"+args[2]+"/1")
		r = s.get(hit)
		print r.status_code
		jdata = r.json()
		if jdata['err'] != 1:
			# print 'here'
			data = jdata['data']
			# print data
			print '-------------------------'
			ontime = data.get('ontime', None)
			offtime = data.get('offtime', None)
			min_order = data.get('minimum_delivery_amount', None)
			del_fee = data.get('delivery_fees', None)
			del_time = data.get('estimated_delivery_time', None)
			service_tax =  data.get('service_tax', None)
			threshold = data.get('promise_time_threshold', None)
			print min_order, offtime
			writer.writerow([args[4], min_order, del_time, del_fee, ontime,
								offtime, service_tax, threshold])

	def f_location_fetcher(self, *args):
		writer = args[3]
		s = requests.session()
		data = dict()
		data['addressLine2'] = args[5]
		data['lat'] = args[0]
		data['lon'] = args[1]
		s.get(self.base_url)
		hit = s.post(self.base_url + 'api/users/location/cart/menu', data=data)
		print hit.status_code
		jdata = hit.json()
		try:
			serviceability =  jdata['cart']['validation']['serviceability']['serviceable']
		except KeyError:
			serviceability = 'keyerror'

		writer.writerow([args[4], args[2], serviceability])


	def get_json(self, search_string, idd, writer):
		apikey = self.google_api_keys[0]
		desc = ''
		r = requests.get('https://maps.googleapis.com/maps/api/place/autocomplete/json?input='+
							search_string
							+'&types=geocode&language=en&key=' + apikey,
							verify = False)
		source = r.json()
		s = requests.session()
		try:
			# getting the first prediction
			key = source['predictions'][0]['place_id']
			desc = source['predictions'][0]['description']
			k = requests.get('https://maps.googleapis.com/maps/api/place/details/json?placeid='+key
			+'&key='+ apikey,verify = False)
			loc = k.json()
			# print loc
			try:
				l = loc['result']['geometry']['location']
				lat = l['lat']
				lng = l['lng']
				name = loc['result']['formatted_address']
				hit = ("some_url/get_store/lat/"+str(lat)+"/lng/"+
								str(lng)+"/locality_name/"+search_string+"/1")
				r = s.get(hit)
				print r.status_code
				jdata = r.json()
				if jdata['err'] != 1:
					# print 'here'
					data = jdata['data']
					# print data
					print '-------------------------'
					ontime = data.get('ontime', None)
					offtime = data.get('offtime', None)
					min_order = data.get('minimum_delivery_amount', None)
					del_fee = data.get('delivery_fees', None)
					del_time = data.get('estimated_delivery_time', None)
					service_tax =  data.get('service_tax', None)
					threshold = data.get('promise_time_threshold', None)
					print min_order, offtime
					writer.writerow([idd, min_order, del_time, del_fee, ontime,
										offtime, service_tax, threshold])
	 		except Exception as e:
	 			print str(e)
				# pprint.pprint(loc)
		except Exception as e:
			print str(e)
			print '------------------------------'

	def main(self, choice):
		# do your main stuff here
		
				



if __name__ == '__main__':
	search_string = raw_input('ENTER city NAME:\n')
	obj = WebDelLocations(search_string)
	choice = raw_input('choice1-->1, choice2-->2\n')
	if choice == '1':
		obj.main(1)
	elif choice == '2':
		obj.main(2)
